// Generated by CoffeeScript 1.3.3
(function() {

  module.exports = (function() {
    var DAY_NAMES, DELIMITER, ISO_8601_DATE, MONTH_NAMES, NUMBER, NUMBER_WITH_ORDINAL, addDays, inject, map, monthFromName, parseExactDateParts, parseExactDay, parseIso8601Date, parseLastOrThisDay, parseNearbyDays, titleize, trim;
    DELIMITER = /[,\s]+/;
    NUMBER = /^[0-9]+$/;
    NUMBER_WITH_ORDINAL = /^([0-9]+)(st|nd|rd|th)?$/;
    ISO_8601_DATE = /^([0-9]{4})-?(1[0-2]|0?[1-9])-?(3[0-1]|[1-2][0-9]|0?[1-9])$/;
    MONTH_NAMES = ['january', 'jan', 'february', 'feb', 'march', 'mar', 'april', 'apr', 'may', 'may', 'june', 'jun', 'july', 'jul', 'august', 'aug', 'september', 'sep', 'october', 'oct', 'november', 'nov', 'december', 'dec'];
    DAY_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    trim = function(string) {
      return string.replace(/^\s+|\s+$/g, '');
    };
    map = function(array, func) {
      var result, x;
      result = [];
      for (x in array) {
        result.push(func(array[x]));
      }
      return result;
    };
    inject = function(array, initialValue, func) {
      var accumulator, x;
      accumulator = initialValue;
      for (x in array) {
        accumulator = func(accumulator, array[x]);
      }
      return accumulator;
    };
    addDays = function(date, numberOfDays) {
      return new Date(date * 1 + numberOfDays * 60 * 60 * 24 * 1000);
    };
    titleize = function(str) {
      return str.replace(/^\w/, function($0) {
        return $0.toUpperCase();
      });
    };
    parseNearbyDays = function(string, today) {
      if (string === 'today') {
        return today;
      }
      if (string === 'yesterday') {
        return addDays(today, -1);
      }
      if (string === 'tomorrow') {
        return addDays(today, +1);
      }
    };
    parseLastOrThisDay = function(string, today) {
      var days, tokens;
      tokens = string.split(DELIMITER);
      if (['last', 'this'].indexOf(tokens[0]) >= 0) {
        days = map([1, 2, 3, 4, 5, 6, 7], function(x) {
          return addDays(today, (tokens[0] === 'last' ? -x : x));
        });
        days = inject(days, {}, function(a, x) {
          a[DAY_NAMES[x.getDay()].toLowerCase()] = x;
          return a;
        });
        return days[tokens[1]];
      }
    };
    parseExactDay = function(string, today) {
      var matches, tokens;
      tokens = string.split(DELIMITER);
      if (tokens.length >= 2) {
        matches = tokens[0].match(NUMBER_WITH_ORDINAL);
        if (matches) {
          return parseExactDateParts(matches[1], tokens[1], tokens[2], today);
        } else {
          matches = tokens[1].match(NUMBER_WITH_ORDINAL);
          if (matches) {
            return parseExactDateParts(matches[1], tokens[0], tokens[2], today);
          } else {
            return null;
          }
        }
      }
    };
    parseExactDateParts = function(rawDay, rawMonth, rawYear, today) {
      var day, month, result, year;
      day = rawDay * 1;
      month = monthFromName(rawMonth);
      year = void 0;
      if (rawYear) {
        year = (rawYear.match(NUMBER) ? rawYear * 1 : null);
      } else {
        year = today.getYear() + 1900;
      }
      if (!(day && month !== null && year)) {
        return null;
      }
      result = new Date(year, month, day);
      if (result.getMonth() !== month || result.getDate() !== day) {
        return null;
      }
      if (result > today && !rawYear) {
        result = new Date(year - 1, month, day);
      }
      return result;
    };
    parseIso8601Date = function(string) {
      var tokens;
      if (string.match(ISO_8601_DATE)) {
        tokens = map(string.split('-'), function(x) {
          return x * 1;
        });
        return new Date(tokens[0], tokens[1] - 1, tokens[2]);
      }
    };
    monthFromName = function(month) {
      var monthIndex;
      monthIndex = MONTH_NAMES.indexOf(month);
      if (monthIndex >= 0) {
        return Math.floor(monthIndex / 2);
      } else {
        return null;
      }
    };
    return {
      parse: function(string) {
        var now;
        now = this.today();
        string = trim(string + "").toLowerCase();
        return parseNearbyDays(string, now) || parseLastOrThisDay(string, now) || parseExactDay(string, now) || parseIso8601Date(string);
      },
      format: function(date, opts) {
        var diff;
        if (!opts) {
          opts = {
            today: this.today()
          };
        }
        diff = Math.floor((date * 1 - opts.today * 1) / 60 / 60 / 24 / 1000);
        switch (diff) {
          case -7:
          case -6:
          case -5:
          case -4:
          case -3:
          case -2:
            return "Last " + DAY_NAMES[date.getDay()];
          case -1:
            return 'Yesterday';
          case 0:
            return 'Today';
          case 1:
            return 'Tomorrow';
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
            return "This " + DAY_NAMES[date.getDay()];
          default:
            return [date.getDate(), titleize(MONTH_NAMES[date.getMonth() * 2]), date.getYear() + 1900].join(' ');
        }
      },
      today: function() {
        return new Date();
      }
    };
  })();

}).call(this);
